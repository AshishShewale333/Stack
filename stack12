Product of the Last K Numbers
Medium
Marks Available: 20.00
Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.

Implement the ProductOfNumbers class:

ProductOfNumbers() Initializes the object with an empty stream.
void add(int num) Appends the integer num to the stream.
int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.
The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.

 

Example:

Input
["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

Output
[null,null,null,null,null,null,20,40,0,null,32]

Explanation
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 
 

Constraints:

0 <= num <= 100
1 <= k <= 4 * 104
At most 4 * 104 calls will be made to add and getProduct.
The product of the stream at any point in time will fit in a 32-bit integer.




‚úÖ Key Idea:
Use a prefix product list to compute the product in constant time.
But since multiplication by 0 resets the product, we must reset the prefix product when a zero is encountered.

‚úÖ Java Code:
java
Copy
Edit
import java.util.ArrayList;
import java.util.List;

class ProductOfNumbers {
    private List<Integer> prefixProducts;

    public ProductOfNumbers() {
        prefixProducts = new ArrayList<>();
        prefixProducts.add(1);  // Dummy prefix product for easier calculation
    }

    public void add(int num) {
        if (num == 0) {
            // Reset on zero
            prefixProducts = new ArrayList<>();
            prefixProducts.add(1);
        } else {
            int lastProduct = prefixProducts.get(prefixProducts.size() - 1);
            prefixProducts.add(lastProduct * num);
        }
    }

    public int getProduct(int k) {
        int size = prefixProducts.size();
        if (k >= size) {
            return 0; // Means zero was added within last k elements
        }
        return prefixProducts.get(size - 1) / prefixProducts.get(size - 1 - k);
    }
}
üí° How It Works:
When a non-zero number is added:
Multiply it with the last prefix product and store the result.

When a zero is added:
Reset the list, since anything multiplied by zero is zero ‚Äî so future getProduct(k) calls must account for this.

When getProduct(k) is called:
Use the formula:

ini
Copy
Edit
product = prefix[n] / prefix[n - k]
Unless zero was in the last k elements (in which case, return 0).

üìå Example Trace:
java
Copy
Edit
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // prefixProducts = [1, 3]
productOfNumbers.add(0);        // reset -> prefixProducts = [1]
productOfNumbers.add(2);        // [1, 2]
productOfNumbers.add(5);        // [1, 2, 10]
productOfNumbers.add(4);        // [1, 2, 10, 40]
productOfNumbers.getProduct(2); // 5 * 4 = 20
productOfNumbers.getProduct(3); // 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // includes zero ‚Üí return 0
productOfNumbers.add(8);        // [1, 2, 10, 40, 320]
productOfNumbers.getProduct(2); // 4 * 8 = 32
‚è± Time and Space Complexity:
add(): O(1)

getProduct(k): O(1)

Space: O(n), where n is the number of elements added since last zero

